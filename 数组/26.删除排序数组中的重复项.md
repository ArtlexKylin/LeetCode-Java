1.[[题目链接]](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

2.思路：<br>
(1)题目的同义转化：<br>
&nbsp;&nbsp;&nbsp;&nbsp;给一个有序数组，返回去掉重复的数组长度，空间复杂度为O(1)<br>
(2)题目的数字转化：<br>
&nbsp;&nbsp;&nbsp;&nbsp;不需要<br>
(3)解决问题的思路：<br>
&nbsp;&nbsp;&nbsp;&nbsp;当当前下标对应元素值，与前一个下标对应的元素值不同的时候，长度+1<br>

3.题解：<br>
(1)双指针法 时间O(n) 空间O(1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;遍历碰到到不同的，放到前面。reason统计有几个不同数的同时，刚好就是需要替换位置的下标。
```java
class Solution {
    public int removeDuplicates(int[] nums) {
        // 遍历从1开始，初始就有1个元素（nums长度为0的话就0个元素）
        int reason = (nums.length==0 ? 0 : 1);

        // i从1开始防止下标越界
        for (int i=1; i<nums.length; ++i) {
            if (nums[i]!=nums[i-1]) {
                // 原地修改nums数组
                // 因为返回的reason是结果数组的长度，只会验证nums的前reason结果对不对。
                // 只需要替换nums[reason]的数，不用删除后面的数
                nums[reason] = nums[i];
                ++reason;
            }
        }
        
        return reason;
    }
}
```